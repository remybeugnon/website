# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Selection criteria"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select the k
checkboxGroupInput("dataset", "Keywords:",
c("rock", "pressure", "cars"),
selected = c("rock")),
# Input: Specify the number of observations to view ----
dateInput("ini.date", 'From:', as.Date("2021-01-01")),
# numericInput("obs", "From:", ),
# sliderInput("obs", "Published year:",
#             min = 2000, max = Sys.Date() %>% str_sub(., 1,4),
#             value = 2000),
# Include clarifying text ----
helpText("Note: while the data view will show only the specified",
"number of observations, the summary will still be based",
"on the full dataset."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
actionButton("update", "Update View")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Header + summary of distribution ----
h4("Map"),
verbatimTextOutput("wordcloud"),
# Output: Header + table of distribution ----
h4("Paper list"),
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(lubridate)
# Return the requested dataset ----
# Note that we use eventReactive() here, which depends on
# input$update (the action button), so that the output is only
# updated when the user clicks the button
datasetInput <- eventReactive(input$update, {
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
}, ignoreNULL = FALSE)
# Generate a summary of the dataset ----
output$wordcloud <- renderPlot({
library(wordcloud2)
wordcloud2(dataset)
})
# Show the first "n" observations ----
# The use of isolate() is necessary because we don't want the table
# to update whenever input$obs changes (only when the user clicks
# the action button)
output$view <- renderTable({
form = read_sheet("https://docs.google.com/spreadsheets/d/1RbL6vgRC_ZvTYL8Qh3uoAFBNeuach2gnLiNW92KxwAA/edit?usp=sharing")
form$Horodateur = form$Horodateur %>% stringr::str_sub(.,1,10) %>% as.Date(.,format = "%Y-%m-%d")
form = form[order(form$Horodateur,  decreasing = T),]
form =
form %>%
# distinct(Title, .keep_all = TRUE) %>%
distinct(`DOI (full URL)`, .keep_all = TRUE) %>%
filter(!is.na(Title))
f = form %>% filter(Horodateur > (input$ini.date)) )
if(nrow(f)>0){
f %>%
mutate(text=paste("<b>", Title, "</b>", " <a href=\"",`DOI (full URL)`,"\">(DOI) </a> ", if(!is.na(Keywords)){Keywords}, if(!is.na(`Comments:`)){`Comments:`},sep="")) %>%
select(text) #%>%
# kable(., format = "html", escape = FALSE, col.names = NULL) %>%
# kable_styling(bootstrap_options = c("hover", "condensed"))
}else{
# kable(x =
c("Nothing was added this week")#, col.names = NULL)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
library(shiny)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Selection criteria"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select the k
checkboxGroupInput("dataset", "Keywords:",
c("rock", "pressure", "cars"),
selected = c("rock")),
# Input: Specify the number of observations to view ----
dateInput("ini.date", 'From:', as.Date("2021-01-01")),
# numericInput("obs", "From:", ),
# sliderInput("obs", "Published year:",
#             min = 2000, max = Sys.Date() %>% str_sub(., 1,4),
#             value = 2000),
# Include clarifying text ----
helpText("Note: while the data view will show only the specified",
"number of observations, the summary will still be based",
"on the full dataset."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
actionButton("update", "Update View")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Header + summary of distribution ----
h4("Map"),
verbatimTextOutput("wordcloud"),
# Output: Header + table of distribution ----
h4("Paper list"),
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(lubridate)
# Return the requested dataset ----
# Note that we use eventReactive() here, which depends on
# input$update (the action button), so that the output is only
# updated when the user clicks the button
datasetInput <- eventReactive(input$update, {
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
}, ignoreNULL = FALSE)
# Generate a summary of the dataset ----
output$wordcloud <- renderPlot({
library(wordcloud2)
wordcloud2(dataset)
})
# Show the first "n" observations ----
# The use of isolate() is necessary because we don't want the table
# to update whenever input$obs changes (only when the user clicks
# the action button)
output$view <- renderTable({
form = read_sheet("https://docs.google.com/spreadsheets/d/1RbL6vgRC_ZvTYL8Qh3uoAFBNeuach2gnLiNW92KxwAA/edit?usp=sharing")
form$Horodateur = form$Horodateur %>% stringr::str_sub(.,1,10) %>% as.Date(.,format = "%Y-%m-%d")
form = form[order(form$Horodateur,  decreasing = T),]
form =
form %>%
# distinct(Title, .keep_all = TRUE) %>%
distinct(`DOI (full URL)`, .keep_all = TRUE) %>%
filter(!is.na(Title))
f = form %>% filter(Horodateur > (input$ini.date)) )
if(nrow(f)>0){
f %>%
mutate(text=paste("<b>", Title, "</b>", " <a href=\"",`DOI (full URL)`,"\">(DOI) </a> ", if(!is.na(Keywords)){Keywords}, if(!is.na(`Comments:`)){`Comments:`},sep="")) %>%
select(text) #%>%
# kable(., format = "html", escape = FALSE, col.names = NULL) %>%
# kable_styling(bootstrap_options = c("hover", "condensed"))
}else{
# kable(x =
c("Nothing was added this week")#, col.names = NULL)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
library(shiny)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Selection criteria"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select the k
checkboxGroupInput("dataset", "Keywords:",
c("rock", "pressure", "cars"),
selected = c("rock")),
# Input: Specify the number of observations to view ----
dateInput("ini.date", 'From:', as.Date("2021-01-01")),
# numericInput("obs", "From:", ),
# sliderInput("obs", "Published year:",
#             min = 2000, max = Sys.Date() %>% str_sub(., 1,4),
#             value = 2000),
# Include clarifying text ----
helpText("Note: while the data view will show only the specified",
"number of observations, the summary will still be based",
"on the full dataset."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
actionButton("update", "Update View")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Header + summary of distribution ----
h4("Map"),
verbatimTextOutput("wordcloud"),
# Output: Header + table of distribution ----
h4("Paper list"),
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(lubridate)
# Return the requested dataset ----
# Note that we use eventReactive() here, which depends on
# input$update (the action button), so that the output is only
# updated when the user clicks the button
datasetInput <- eventReactive(input$update, {
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
}, ignoreNULL = FALSE)
# Generate a summary of the dataset ----
output$wordcloud <- renderPlot({
library(wordcloud2)
wordcloud2(dataset)
})
# Show the first "n" observations ----
# The use of isolate() is necessary because we don't want the table
# to update whenever input$obs changes (only when the user clicks
# the action button)
output$view <- renderTable({
form = read_sheet("https://docs.google.com/spreadsheets/d/1RbL6vgRC_ZvTYL8Qh3uoAFBNeuach2gnLiNW92KxwAA/edit?usp=sharing")
1
form$Horodateur = form$Horodateur %>% stringr::str_sub(.,1,10) %>% as.Date(.,format = "%Y-%m-%d")
form = form[order(form$Horodateur,  decreasing = T),]
form =
form %>%
# distinct(Title, .keep_all = TRUE) %>%
distinct(`DOI (full URL)`, .keep_all = TRUE) %>%
filter(!is.na(Title))
f = form %>% filter(Horodateur > (input$ini.date)) )
if(nrow(f)>0){
f %>%
mutate(text=paste("<b>", Title, "</b>", " <a href=\"",`DOI (full URL)`,"\">(DOI) </a> ", if(!is.na(Keywords)){Keywords}, if(!is.na(`Comments:`)){`Comments:`},sep="")) %>%
select(text) #%>%
# kable(., format = "html", escape = FALSE, col.names = NULL) %>%
# kable_styling(bootstrap_options = c("hover", "condensed"))
}else{
# kable(x =
c("Nothing was added this week")#, col.names = NULL)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
library(shiny)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Selection criteria"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select the k
checkboxGroupInput("dataset", "Keywords:",
c("rock", "pressure", "cars"),
selected = c("rock")),
# Input: Specify the number of observations to view ----
dateInput("ini.date", 'From:', as.Date("2021-01-01")),
# numericInput("obs", "From:", ),
# sliderInput("obs", "Published year:",
#             min = 2000, max = Sys.Date() %>% str_sub(., 1,4),
#             value = 2000),
# Include clarifying text ----
helpText("Note: while the data view will show only the specified",
"number of observations, the summary will still be based",
"on the full dataset."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
actionButton("update", "Update View")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Header + summary of distribution ----
h4("Map"),
verbatimTextOutput("wordcloud"),
# Output: Header + table of distribution ----
h4("Paper list"),
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(lubridate)
# Return the requested dataset ----
# Note that we use eventReactive() here, which depends on
# input$update (the action button), so that the output is only
# updated when the user clicks the button
datasetInput <- eventReactive(input$update, {
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
}, ignoreNULL = FALSE)
# Generate a summary of the dataset ----
output$wordcloud <- renderPlot({
library(wordcloud2)
wordcloud2(dataset)
})
# Show the first "n" observations ----
# The use of isolate() is necessary because we don't want the table
# to update whenever input$obs changes (only when the user clicks
# the action button)
output$view <- renderTable({
form = read_sheet("https://docs.google.com/spreadsheets/d/1RbL6vgRC_ZvTYL8Qh3uoAFBNeuach2gnLiNW92KxwAA/edit?usp=sharing")
form$Horodateur = form$Horodateur %>% stringr::str_sub(.,1,10) %>% as.Date(.,format = "%Y-%m-%d")
form = form[order(form$Horodateur,  decreasing = T),]
form =
form %>%
# distinct(Title, .keep_all = TRUE) %>%
distinct(`DOI (full URL)`, .keep_all = TRUE) %>%
filter(!is.na(Title))
form
}
# Create Shiny app ----
shinyApp(ui, server)
library(shiny)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Selection criteria"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select the k
checkboxGroupInput("dataset", "Keywords:",
c("rock", "pressure", "cars"),
selected = c("rock")),
# Input: Specify the number of observations to view ----
dateInput("ini.date", 'From:', as.Date("2021-01-01")),
# numericInput("obs", "From:", ),
# sliderInput("obs", "Published year:",
#             min = 2000, max = Sys.Date() %>% str_sub(., 1,4),
#             value = 2000),
# Include clarifying text ----
helpText("Note: while the data view will show only the specified",
"number of observations, the summary will still be based",
"on the full dataset."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
actionButton("update", "Update View")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Header + summary of distribution ----
h4("Map"),
verbatimTextOutput("wordcloud"),
# Output: Header + table of distribution ----
h4("Paper list"),
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(lubridate)
# Return the requested dataset ----
# Note that we use eventReactive() here, which depends on
# input$update (the action button), so that the output is only
# updated when the user clicks the button
datasetInput <- eventReactive(input$update, {
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
}, ignoreNULL = FALSE)
# Generate a summary of the dataset ----
output$wordcloud <- renderPlot({
library(wordcloud2)
wordcloud2(dataset)
})
# Show the first "n" observations ----
# The use of isolate() is necessary because we don't want the table
# to update whenever input$obs changes (only when the user clicks
# the action button)
output$view <- renderTable({
form = read_sheet("https://docs.google.com/spreadsheets/d/1RbL6vgRC_ZvTYL8Qh3uoAFBNeuach2gnLiNW92KxwAA/edit?usp=sharing")
form$Horodateur = form$Horodateur %>% stringr::str_sub(.,1,10) %>% as.Date(.,format = "%Y-%m-%d")
form = form[order(form$Horodateur,  decreasing = T),]
form =
form %>%
# distinct(Title, .keep_all = TRUE) %>%
distinct(`DOI (full URL)`, .keep_all = TRUE) %>%
filter(!is.na(Title))
form
}
}
# Create Shiny app ----
shinyApp(ui, server)
library(shiny)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Selection criteria"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select the k
checkboxGroupInput("dataset", "Keywords:",
c("rock", "pressure", "cars"),
selected = c("rock")),
# Input: Specify the number of observations to view ----
dateInput("ini.date", 'From:', as.Date("2021-01-01")),
# numericInput("obs", "From:", ),
# sliderInput("obs", "Published year:",
#             min = 2000, max = Sys.Date() %>% str_sub(., 1,4),
#             value = 2000),
# Include clarifying text ----
helpText("Note: while the data view will show only the specified",
"number of observations, the summary will still be based",
"on the full dataset."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
actionButton("update", "Update View")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Header + summary of distribution ----
h4("Map"),
verbatimTextOutput("wordcloud"),
# Output: Header + table of distribution ----
h4("Paper list"),
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(lubridate)
# Return the requested dataset ----
# Note that we use eventReactive() here, which depends on
# input$update (the action button), so that the output is only
# updated when the user clicks the button
datasetInput <- eventReactive(input$update, {
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
}, ignoreNULL = FALSE)
# Generate a summary of the dataset ----
output$wordcloud <- renderPlot({
library(wordcloud2)
wordcloud2(dataset)
})
# Show the first "n" observations ----
# The use of isolate() is necessary because we don't want the table
# to update whenever input$obs changes (only when the user clicks
# the action button)
output$view <- renderTable({
form = read_sheet("https://docs.google.com/spreadsheets/d/1RbL6vgRC_ZvTYL8Qh3uoAFBNeuach2gnLiNW92KxwAA/edit?usp=sharing")
form$Horodateur = form$Horodateur %>% stringr::str_sub(.,1,10) %>% as.Date(.,format = "%Y-%m-%d")
form = form[order(form$Horodateur,  decreasing = T),]
form =
form %>%
# distinct(Title, .keep_all = TRUE) %>%
distinct(`DOI (full URL)`, .keep_all = TRUE) %>%
filter(!is.na(Title))
cars
}
}
# Create Shiny app ----
shinyApp(ui, server)
blogdown:::preview_site()
options(blogdown.hugo.dir = '/Applications/hugo')
blogdown::serve_site()
